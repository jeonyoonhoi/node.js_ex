'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('cli-spinner'),
    Spinner = _require.Spinner;

var chalk = require('chalk');
var inquirer = require('inquirer');

var powershell = require('./powershell');
var utils = require('./utils');
var strings = require('./strings');
var versions = require('./versions');
var findNpm = require('./find-npm');
var debug = require('./debug');

// eslint-disable-next-line no-use-before-define
var regeneratorRuntime = regeneratorRuntime || require('regenerator-runtime-only');

var Upgrader = function () {
  function Upgrader(program) {
    _classCallCheck(this, Upgrader);

    this.options = program;

    if (this.options.prompt === false) {
      this.options.spinner = false;
    }
  }

  /**
   * Executes the upgrader's "let's check the user's internet" logic,
   * eventually quietly resolving or quitting the process with an
   * error if the connection is not sufficient
   */


  _createClass(Upgrader, [{
    key: 'ensureInternet',
    value: function ensureInternet() {
      var isOnline;
      return regeneratorRuntime.async(function ensureInternet$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(this.options.dnsCheck !== false)) {
                _context.next = 5;
                break;
              }

              _context.next = 3;
              return regeneratorRuntime.awrap(utils.checkInternetConnection());

            case 3:
              isOnline = _context.sent;


              if (!isOnline) {
                utils.exit(1, strings.noInternet);
              }

            case 5:
            case 'end':
              return _context.stop();
          }
        }
      }, null, this);
    }

    /**
     * Executes the upgrader's "let's check the user's powershell execution
     * policy" logic, eventually quietly resolving or quitting the process
     * with an error if the policy is not sufficient
     */

  }, {
    key: 'ensureExecutionPolicy',
    value: function ensureExecutionPolicy() {
      var isExecutable;
      return regeneratorRuntime.async(function ensureExecutionPolicy$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(this.options.executionPolicyCheck !== false)) {
                _context2.next = 11;
                break;
              }

              _context2.prev = 1;
              _context2.next = 4;
              return regeneratorRuntime.awrap(utils.checkExecutionPolicy());

            case 4:
              isExecutable = _context2.sent;


              if (!isExecutable) {
                utils.exit(1, strings.noExecutionPolicy);
              }
              _context2.next = 11;
              break;

            case 8:
              _context2.prev = 8;
              _context2.t0 = _context2['catch'](1);

              utils.exit(1, strings.executionPolicyCheckError, _context2.t0);

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, null, this, [[1, 8]]);
    }

    /**
     * Checks if the upgrade was successful
     *
     * @return {boolean} - was the upgrade successful?
     */

  }, {
    key: 'wasUpgradeSuccessful',
    value: function wasUpgradeSuccessful() {
      return regeneratorRuntime.async(function wasUpgradeSuccessful$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return regeneratorRuntime.awrap(versions.getInstalledNPMVersion());

            case 2:
              this.installedVersion = _context3.sent;
              return _context3.abrupt('return', this.installedVersion === this.options.npmVersion);

            case 4:
            case 'end':
              return _context3.stop();
          }
        }
      }, null, this);
    }

    /**
     * Executes the upgrader's "let's have the user choose a version" logic
     */

  }, {
    key: 'chooseVersion',
    value: function chooseVersion() {
      var availableVersions, versionList;
      return regeneratorRuntime.async(function chooseVersion$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (this.options.npmVersion) {
                _context4.next = 8;
                break;
              }

              _context4.next = 3;
              return regeneratorRuntime.awrap(versions.getAvailableNPMVersions());

            case 3:
              availableVersions = _context4.sent;
              versionList = [{
                type: 'list',
                name: 'version',
                message: 'Which version do you want to install?',
                choices: availableVersions.reverse()
              }];
              _context4.next = 7;
              return regeneratorRuntime.awrap(inquirer.prompt(versionList).then(function (answer) {
                return answer.version;
              }));

            case 7:
              this.options.npmVersion = _context4.sent;

            case 8:
              if (!(this.options.npmVersion === 'latest')) {
                _context4.next = 12;
                break;
              }

              _context4.next = 11;
              return regeneratorRuntime.awrap(versions.getLatestNPMVersion());

            case 11:
              this.options.npmVersion = _context4.sent;

            case 12:
            case 'end':
              return _context4.stop();
          }
        }
      }, null, this);
    }

    /**
     * Executes the upgrader's "let's find npm" logic
     */

  }, {
    key: 'choosePath',
    value: function choosePath() {
      var npmPaths;
      return regeneratorRuntime.async(function choosePath$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return regeneratorRuntime.awrap(findNpm(this.options.npmPath));

            case 3:
              npmPaths = _context5.sent;


              this.log(npmPaths.message);
              this.options.npmPath = npmPaths.path;

              debug('Upgrader: Chosen npm path: ' + this.options.npmPath);
              _context5.next = 12;
              break;

            case 9:
              _context5.prev = 9;
              _context5.t0 = _context5['catch'](0);

              utils.exit(1, _context5.t0);

            case 12:
            case 'end':
              return _context5.stop();
          }
        }
      }, null, this, [[0, 9]]);
    }

    /**
     * Attempts a simple upgrade, eventually calling npm install -g npm
     *
     * @param {string} version - Version that should be installed
     * @private
     */

  }, {
    key: 'upgradeSimple',
    value: function upgradeSimple() {
      var output;
      return regeneratorRuntime.async(function upgradeSimple$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              this.spinner = new Spinner(strings.startingUpgradeSimple + ' %s');

              if (this.options.spinner === false) {
                console.log(strings.startingUpgradeSimple);
              } else {
                this.spinner.start();
              }

              _context6.next = 4;
              return regeneratorRuntime.awrap(powershell.runSimpleUpgrade(this.options.npmVersion));

            case 4:
              output = _context6.sent;


              this.spinner.stop(false);
              console.log('\n');

              if (!output.error) {
                _context6.next = 9;
                break;
              }

              throw output.error;

            case 9:
            case 'end':
              return _context6.stop();
          }
        }
      }, null, this);
    }

    /**
     * Upgrades npm in the correct directory, securing and reapplying
     * existing configuration
     *
     * @param  {string} version - Version that should be installed
     * @param  {string} npmPath - Path where npm should be installed
     * @private
     */

  }, {
    key: 'upgradeComplex',
    value: function upgradeComplex() {
      var output;
      return regeneratorRuntime.async(function upgradeComplex$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              this.spinner = new Spinner(strings.startingUpgradeComplex + ' %s');

              if (this.options.spinner === false) {
                console.log(strings.startingUpgradeComplex);
              } else {
                this.spinner.start();
              }

              _context7.next = 4;
              return regeneratorRuntime.awrap(powershell.runUpgrade(this.options.npmVersion, this.options.npmPath));

            case 4:
              output = _context7.sent;


              this.spinner.stop(false);
              console.log('\n');

              // If we failed to elevate to administrative rights, we have to abort.
              if (output.stdout[0] && output.stdout[0].includes('NOTADMIN')) {
                utils.exit(1, strings.noAdmin);
              }

            case 8:
            case 'end':
              return _context7.stop();
          }
        }
      }, null, this);
    }

    /**
     * Executes the full upgrade flow
     */

  }, {
    key: 'upgrade',
    value: function upgrade() {
      var _this = this;

      debug('Starting upgrade');

      return this.upgradeComplex().then(function () {
        return _this.wasUpgradeSuccessful();
      }).then(function (isDone) {
        if (isDone) {
          // Awesome, the upgrade worked!
          utils.exit(0, strings.upgradeFinished(_this.installedVersion));
        } else {
          return _this.upgradeSimple();
        }
      }).then(function () {
        return _this.wasUpgradeSuccessful();
      }).then(function (isDone) {
        if (isDone) {
          // Awesome, the upgrade worked!
          utils.exit(0, strings.upgradeFinished(_this.installedVersion));
        } else {
          _this.logUpgradeFailure();
        }
      }).catch(function (err) {
        return console.log(err);
      });
    }

    /**
     * Logs a message to console, unless the user specified quiet mode
     *
     * @param {string} message - message to log
     * @private
     */

  }, {
    key: 'log',
    value: function log(message) {
      if (!this.options.quiet) {
        console.log(message);
      }
    }

    /**
     * If the whole upgrade failed, we use this method to log a
     * detailed trace with versions - all to make it easier for
     * users to create meaningful issues.
     *
     * @param errors {array} - AS many errors as found
     */

  }, {
    key: 'logUpgradeFailure',
    value: function logUpgradeFailure() {
      var _this2 = this;

      for (var _len = arguments.length, errors = Array(_len), _key = 0; _key < _len; _key++) {
        errors[_key] = arguments[_key];
      }

      // Uh-oh, something didn't work as it should have.
      versions.getVersions().then(function (debugVersions) {
        var info = void 0;

        if (_this2.options.npmVersion && _this2.installedVersion) {
          info = 'You wanted to install npm ' + _this2.options.npmVersion + ', but the installed version is ' + _this2.installedVersion + '.\n\n';
          info += 'A common reason is an attempted "npm install npm" or "npm upgrade npm". ';
          info += 'As of today, the only solution is to completely uninstall and then reinstall Node.js. ';
          info += 'For a small tutorial, please see https://github.com/felixrieseberg/npm-windows-upgrade#usage.\n';
        } else if (_this2.options.npmVersion) {
          info = 'You wanted to install npm ' + _this2.options.npmVersion + ', but we could not confirm that the installation succeeded.';
        } else {
          info = 'We encountered an error during installation.\n';
        }

        info += '\nPlease consider reporting your trouble to https://aka.ms/npm-issues.';

        console.log(chalk.red(info));
        console.log(chalk.bold('\nDebug Information:\n'));
        console.log(debugVersions);

        if (errors && errors.length && errors.length > 0) console.log('Here is the error:');

        // If we just got an error string (we shouldn't handle that)
        if (typeof errors !== 'string') {
          console.log('\n' + errors + '\n');
          return process.exit(1);
        }

        for (var i = 0; i < errors.length; i++) {
          console.log('\n' + errors[i] + '\n');
        }

        setTimeout(function () {
          process.exit(1);
        }, 1000);
      });
    }
  }]);

  return Upgrader;
}();

module.exports = Upgrader;
//# sourceMappingURL=upgrader.js.map